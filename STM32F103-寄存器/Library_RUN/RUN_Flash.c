#include "RUN_Flash.h"

// ==============================================================================
// 内部缓冲区
// ==============================================================================
// 
// 上图展示了 Flash 的存储结构：Flash 是按 "页 (Page)" 划分的。
// STM32F103 ZET6 (大容量) 一页通常是 2KB (2048字节)。
// STM32F103 C8T6 (中容量) 一页通常是 1KB (1024字节)。
// 写入前必须整页擦除，因此我们需要一个 RAM 缓存来暂存整页数据。

static uint8_t Flash_Cache_Buffer[FLASH_PAGE_SIZE];

// ==============================================================================
// 函数实现
// ==============================================================================

//-------------------------------------------------------------------------------------------------------------------
// 函数简介      从 Flash 读取任意长度数据
// 参数说明      offset          页内偏移量 (0 ~ PAGE_SIZE-1)
// 参数说明      pData           用户接收数据的缓冲区指针
// 参数说明      len             读取长度 (字节)
// 返回参数      void
// 使用示例      uint8_t dt[10]; RUN_Flash_Read(0, dt, 10);
// 备注信息      Flash 在 STM32 中是 "内存映射" 的 (Memory Mapped)。
//               这意味着读取 Flash 和读取普通变量一样，直接指针访问即可，无需特殊寄存器交互。
//-------------------------------------------------------------------------------------------------------------------
void RUN_Flash_Read(uint16_t offset, void *pData, uint16_t len)
{
    // 1. 越界检查
    if(offset + len > FLASH_PAGE_SIZE) return;

    // 2. 直接内存拷贝
    // (const void*) 强制转换是因为 Flash 地址通常被定义为常量
    // FLASH_START_ADDR 必须在头文件中定义 (如 0x0800F800，即最后一页的起始地址)
    memcpy(pData, (const void*)(FLASH_START_ADDR + offset), len);
}

// 
// 上图展示了 Flash 写入的标准流程：解锁 -> 擦除(置1) -> 编程(写0) -> 上锁。
// 注意：Flash 的物理特性决定了位只能从 1 变成 0。如果想把 0 变成 1，必须执行擦除操作。

//-------------------------------------------------------------------------------------------------------------------
// 函数简介      向 Flash 写入数据 (保留同页其他数据)
// 参数说明      offset          页内偏移量
// 参数说明      pData           要写入的数据指针
// 参数说明      len             写入长度
// 返回参数      void
// 使用示例      uint8_t save[2] = {0xAA, 0xBB}; RUN_Flash_Write(0, save, 2);
// 备注信息      采用 "读-改-写" 策略：
//               1. 读出整页到 RAM。
//               2. 修改 RAM 中的指定数据。
//               3. 擦除整页 Flash。
//               4. 将 RAM 数据写回 Flash。
//-------------------------------------------------------------------------------------------------------------------
void RUN_Flash_Write(uint16_t offset, void *pData, uint16_t len)
{
    uint16_t i;
    volatile FLASH_Status FLASHStatus = FLASH_COMPLETE;
    
    // 0. 安全检查
    if(offset + len > FLASH_PAGE_SIZE) return;

    // ==========================================================
    // 第一步：备份 (Backup)
    // ==========================================================
    // 将 Flash 当前页的所有内容拷贝到 RAM 缓存数组中
    // 这样是为了防止擦除后，非修改区域的数据丢失
    memcpy(Flash_Cache_Buffer, (const void*)FLASH_START_ADDR, FLASH_PAGE_SIZE);
    
    // ==========================================================
    // 第二步：修改 (Modify)
    // ==========================================================
    // 在 RAM 缓存中，将用户的新数据覆盖到对应位置
    // 此时 Flash_Cache_Buffer 包含了 "旧的未动数据" + "新的修改数据"
    memcpy(&Flash_Cache_Buffer[offset], pData, len);
    
    // ==========================================================
    // 第三步：写入 (Write Back)
    // ==========================================================
    
    // 1. 解锁 Flash 控制器
    // 允许对 Flash 寄存器进行写操作
    FLASH_Unlock();
    
    // 2. 清除标志位
    // 清除之前的错误标志 (操作结束位、编程错误、写保护错误)，确保本次操作环境干净
    FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR); 
    
    // 3. 擦除整页
    // 执行页擦除指令，该页所有位变为 1 (0xFF)
    // 如果不擦除直接写，只能将 1 写为 0，无法将 0 写为 1，数据会出错
    FLASHStatus = FLASH_ErasePage(FLASH_START_ADDR);
    
    // 4. 编程 (Programming)
    if(FLASHStatus == FLASH_COMPLETE)
    {
        // STM32F1 Flash 只能按 "半字 (HalfWord, 16bit)" 写入
        // 所以我们需要将 8位 的 buffer 指针强转为 16位 指针
        uint16_t *pWord = (uint16_t *)Flash_Cache_Buffer;
        
        // 循环次数 = 总字节数 / 2
        for(i = 0; i < FLASH_PAGE_SIZE / 2; i++)
        {
            // 地址每次 +2 (i*2)
            // 数据每次取 1个 uint16_t
            FLASH_ProgramHalfWord(FLASH_START_ADDR + (i * 2), pWord[i]);
        }
    }
    
    // 5. 上锁
    // 禁止后续的误操作修改 Flash
    FLASH_Lock();
}