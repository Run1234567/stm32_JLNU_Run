#include "RUN_DS18B20.h"
#include "RUN_OneWire.h" // 依赖底层的单总线驱动

// 
// 上图展示了 DS18B20 的引脚和内部结构：
// 1. DQ: 数据引脚 (需上拉)。
// 2. 内部有 64-bit ROM (唯一ID)。
// 3. 核心是 9字节的暂存器 (Scratchpad)，用于存放温度、配置和报警值。

// ==========================================================
// 初始化函数
// ==========================================================
void RUN_DS18B20_Init(GPIO_TypeDef* port, uint16_t pin)
{
    // DS18B20 本身不需要复杂的寄存器配置，
    // 它的初始化完全依赖于单总线 (OneWire) 的时序初始化。
    RUN_OneWire_Init(port, pin);
}

// 
// 上图展示了 "暂存器 (Scratchpad)" 的 9 字节分布：
// Byte 0: 温度低 8 位 (LSB)
// Byte 1: 温度高 8 位 (MSB)
// Byte 2/3: 高低温报警触发值
// Byte 4: 配置寄存器 (决定精度 9~12位)
// ...
// Byte 8: CRC 校验码

// ==========================================================
// 读取温度核心函数
// ==========================================================

//-------------------------------------------------------------------------------------------------------------------
// 函数简介      读取温度值 (摄氏度)
// 返回参数      float 温度值 (范围 -55.0 ~ +125.0)
// 备注信息      【重要时序说明】
//               DS18B20 转换温度需要时间 (12位精度最大需 750ms)。
//               本函数采用 "启动转换 -> 立即读取" 的逻辑，有以下两种使用策略：
//               策略A (简单): 在函数中间加 delay_ms(750)。优点是数据即时，缺点是 CPU 死等。
//               策略B (高效): 在主循环每 1秒 调用一次。此时读到的是 "上一次" 转换的结果。
//                             (第一次调用可能会读到 85.0°C，这是上电默认值)。
//-------------------------------------------------------------------------------------------------------------------
float RUN_DS18B20_GetTemp(void)
{
    uint8_t temp_L, temp_H;
    int16_t temp_raw;
    float temperature;

    // ==========================================
    // 第一步：启动温度转换 (Convert T)
    // ==========================================
    RUN_OneWire_Reset();          // 1. 复位脉冲
    RUN_OneWire_WriteByte(0xCC);  // 2. 跳过 ROM 指令 (0xCC)
                                  //    如果不跳过，就得发送 64位 ID 来匹配特定传感器。
                                  //    "跳过" 意味着总线上只能挂一个 DS18B20，或者我对所有设备广播。
    
    RUN_OneWire_WriteByte(0x44);  // 3. 温度转换指令 (0x44)
    
    // 【关键点】
    // 发送完 0x44 后，传感器内部开始模拟转数字 (ADC)。
    // 12位精度下，这个过程最长需要 750ms。
    // 如果这里不延时直接去读，读出来的可能是上一次的数据，或者是 85.0 (默认值)。
    
    // 如果您希望 CPU 在这里等待结果，请取消下行注释：
    // RUN_delay_ms(750); 

    // ==========================================
    // 第二步：读取暂存器 (Read Scratchpad)
    // ==========================================
    RUN_OneWire_Reset();          // 4. 再次复位 (打断之前的状态，准备新指令)
    RUN_OneWire_WriteByte(0xCC);  // 5. 跳过 ROM
    RUN_OneWire_WriteByte(0xBE);  // 6. 读暂存器指令 (0xBE)
    
    // DS18B20 会按顺序送出 9 个字节的数据。
    // 我们只需要前两个字节 (温度数据)。
    temp_L = RUN_OneWire_ReadByte(); // Byte 0: LSB
    temp_H = RUN_OneWire_ReadByte(); // Byte 1: MSB
    
    // (如果需要严谨，可以继续读完后面 7 个字节并做 CRC 校验)

    // ==========================================
    // 第三步：数据合成与计算
    // ==========================================
    
    // 
    // 上图展示了 16位 原始数据的格式：
    // 高 5 位 (Bit 15-11) 是符号位 (Sign)，全 0 表示正，全 1 表示负。
    // 低 4 位 (Bit 3-0) 是小数部分。
    
    // 合成 16位 整数
    // 强制转换为 int16_t 是为了处理负数 (利用补码特性)
    temp_raw = (int16_t)((temp_H << 8) | temp_L);
    
    // 计算物理值
    // DS18B20 的分辨率是 0.0625 (即 $2^{-4}$ 或 1/16)
    // 公式: $Temperature = RawValue \times 0.0625$
    temperature = (float)temp_raw * 0.0625f;
    
    return temperature;
}