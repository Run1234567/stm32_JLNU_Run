#include "RUN_header_file.h"

// ==============================================================================
// 全局变量
// ==============================================================================
// 用于存储 1us 所需的 SysTick 计数值
// 例如：主频 72MHz，8分频后为 9MHz，则 1us 需要 9 个时钟周期 -> fac_us = 9
static uint8_t fac_us = 0;

// 
// 上图展示了 SysTick 的核心结构：它是一个 24 位的向下计数器，内含 LOAD(重装载)、VAL(当前值)、CTRL(控制) 三个主要寄存器。

// ==============================================================================
// 函数实现
// ==============================================================================

//-------------------------------------------------------------------------------------------------------------------
// 函数简介      SysTick 延时初始化函数
// 参数说明      sysclk_mhz      系统主时钟频率 (单位: MHz)
// 参数说明                      对于 STM32F103 (ZET6/C8T6)，通常填 72
// 返回参数      void
// 使用示例      RUN_delay_init(72); // 在 main 函数开头调用
// 备注信息      配置 SysTick 时钟源为 HCLK/8，并计算微秒倍乘因子
//-------------------------------------------------------------------------------------------------------------------
void RUN_delay_init(uint8_t sysclk_mhz)
{
    // 1. 配置 SysTick 时钟源
    // 选择外部时钟源 (STCLK)，即 HCLK 的 8 分频
    // 公式：SysTick_CLK = 72MHz / 8 = 9MHz
    SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);

    // 2. 计算 1us 需要的计数值 (fac_us)
    // 频率 9MHz 意味着 1秒 震动 9M 次
    // 1us = 1/1,000,000 秒
    // 计数次数 = 9,000,000 / 1,000,000 = 9 次
    fac_us = sysclk_mhz / 8;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介      微秒级延时函数 (us)
// 参数说明      nus             延时微秒数
// 返回参数      void
// 使用示例      RUN_delay_us(50); // 延时 50us
// 备注信息      【注意】由于 LOAD 寄存器是 24 位的 (最大值 0xFFFFFF = 16,777,215)，
//               且 fac_us=9，因此单次延时最大值为：16777215 / 9 ≈ 1,864,135 us (约 1.86秒)。
//               超过此值会导致计算溢出，延时错误。
//-------------------------------------------------------------------------------------------------------------------
void RUN_delay_us(uint32_t nus)
{
    uint32_t temp;
    
    // 
    // 上图展示了 SysTick 的工作方式：从 LOAD 值开始向下计数，减到 0 时置位 COUNTFLAG 并重置。

    // 1. 设置重装载值 (LOAD)
    // 计数值 = 延时微秒数 * 每微秒的跳数
    SysTick->LOAD = nus * fac_us;
    
    // 2. 清空当前计数值 (VAL)
    // 写入任何值都会清空 VAL 寄存器，确保从 LOAD 值开始准确计数
    SysTick->VAL = 0x00;
    
    // 3. 开启 SysTick (CTRL)
    // 置位 ENABLE 位，开始倒计数
    SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;

    // 4. 等待计数完成 (Blocking Wait)
    do
    {
        temp = SysTick->CTRL;
    } 
    // 判断条件：
    // (temp & 0x01)       : 确保定时器还在开启状态 (防止意外关闭导致死循环)
    // !(temp & (1 << 16)) : 检查第 16 位 (COUNTFLAG)。
    //                       当计数减到 0 时，硬件会将该位置 1。
    //                       !(...): 如果没置 1，就继续循环等待。
    while ((temp & 0x01) && !(temp & (1 << 16)));

    // 5. 关闭 SysTick
    // 清除 ENABLE 位，停止计数，节省功耗
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
    
    // 6. 清空计数器
    SysTick->VAL = 0x00;
}

//-------------------------------------------------------------------------------------------------------------------
// 函数简介      毫秒级延时函数 (ms)
// 参数说明      nms             延时毫秒数
// 返回参数      void
// 使用示例      RUN_delay_ms(500); // 延时 500ms
// 备注信息      利用循环调用微秒延时实现。
//               优点：1. 避免了 fac_ms 变量的计算。
//                     2. 规避了 SysTick 24位寄存器的溢出限制，支持长时间延时 (如 10秒)。
//-------------------------------------------------------------------------------------------------------------------
void RUN_delay_ms(uint16_t nms)
{
    uint32_t i;
    for (i = 0; i < nms; i++)
    {
        RUN_delay_us(1000); // 每次延时 1ms (1000us)
    }
}